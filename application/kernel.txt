
kernel void MulMatrix(global const double* A, global const double* B,
                      global double* C, constant int* ptrSize) {
  int i = get_global_id(1);
  int j = get_global_id(0);
  int size = *ptrSize;


 C[i*size+j] = 0;
  for (int k = 0; k < size; ++k)
    C[i * size + j] += A[i * size + k] * B[k * size + j];

//barrier(CLK_GLOBAL_MEM_FENCE);
//printf("%i ", C[i * size + j]);

}


kernel void MulMatrixOpt(global  double* a, global double* b,
                         global double* c, constant int* size_ptr,
                         local double* a_local, local double* b_local,
                         constant int* blocksize_ptr) {
  int j = get_global_id(0);
  int i = get_global_id(1);
  barrier(CLK_GLOBAL_MEM_FENCE);

  int size = *size_ptr;
  int BLOCK_SIZE = *blocksize_ptr;

  int localJ = get_local_id(0);
  int localI = get_local_id(1);

  double sum = 0.0f;


  for (int p = 0; p < size / BLOCK_SIZE; ++p) {
    a_local[localI * BLOCK_SIZE + localJ] =
        a[i * size + p * BLOCK_SIZE + localJ];
    b_local[localI * BLOCK_SIZE + localJ] =
        b[(p * BLOCK_SIZE + localI) * size + j];
    barrier(CLK_LOCAL_MEM_FENCE);

    for (int l = 0; l < BLOCK_SIZE; ++l) {
      sum +=
          a_local[localI * BLOCK_SIZE + l] * b_local[l * BLOCK_SIZE + localJ];
    }
    barrier(CLK_LOCAL_MEM_FENCE);
  }

  c[i * size + j] = sum;



 //printf("%d ", c[i*size+j]);
 
}


kernel void Convolution(global double* in, global double* out, 
			constant int* ptr_size, global double* kern, 
				constant int* ptr_radius){

int i = get_global_id(1);//y
int j = get_global_id(0);//x
int size = *ptr_size;
int radius = *ptr_radius;


int r;
int center = (2*radius+1)*(radius)+radius;
double sum = in[i*size+j]*kern[center];
out[i*size+j] = 0;
for(r = 1; r <= radius; ++r){

if( j - r >= 0 && j + r < size && i - r >= 0 && i + r < size){

sum+= in[i*size+(j+r)]*kern[center + r] + in[i*size+(j-r)]*kern[center-r]
      + in[(i+r)*size+j]*kern[center+2*r*r+1] +in[(i-r)*size+j]*kern[center-2*r*r-1]
      + in[(i-r)*size+(j-r)]*kern[center-2*r*r-1 - r]+ in[(i+r)*size+(j+r)]*kern[center+2*r*r+1 + r]
      + in[(i+r)*size+(j-r)]*kern[center+2*r*r+1 - r] + in[(i-r)*size+(j+r)]*kern[center-2*r*r-1 + r];
}



}

out[i*size+j] = sum;

} 


double f_(double x)
{
    return fabs(sin(x)*cos(x)*exp(1/x)*log(x)*cbrt(x)*sqrt(fabs(x)))+1;
}

double f(double x, double y)
{
    return f_(x*y)/f_(x+y)+f_(x/y)/f_(pow(y,x))+f_(y/x)/f_(pow(x,y)) + f_(x)/f_(y);
}


double trap(double a, double b, double c, double d)
{
   
    return ((b-a)*(d-c)/36)*(f(a,c)+f(a,d)+f(b,c)+f(b,d)+
			4*(f(a, c/2+d/2)+f(b, c/2+d/2)+f(a/2+b/2, c)+f(a/2+b/2, d))+
			16*f(a/2+b/2, c/2+ d/2));
}

kernel void Integration(
    constant double* ptr_a,
    constant double* ptr_b,
	 constant double* ptr_c,
	 constant double* ptr_d,
	 constant unsigned int* ptr_split,
    global double* sums)
{
	
	double a = *ptr_a;
	double b = *ptr_b;
	double c = *ptr_c;
	double d = *ptr_d;
	unsigned int split = *ptr_split;



    int x_id = get_global_id(0);
	int y_id = get_global_id(1);

	sums[x_id*split+y_id] = 0;

    double a1 = a+((b-a)/split)*get_global_id(0);
    double b1 = a1+(b-a)/split;
	double c1 = c+((d-c)/split)*get_global_id(1);
	double d1 = c1+(d-c)/split;
  
    sums[x_id*split+y_id] = trap(a1, b1, c1, d1) ;

}


kernel void DotProduct(global const double* A, global const double* B,
                      global double* C, constant int* ptrSize) {
  int i = get_global_id(0);
  int size = *ptrSize;


 C[i] = A[i]*B[i];
   

}